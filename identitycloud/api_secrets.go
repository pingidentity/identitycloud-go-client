// Copyright Â© 2025 Ping Identity Corporation

/*
PingOne Advanced Identity Cloud API

## Introduction The PingOne Advanced Identity Cloud REST API lets you manage your Advanced Identity Cloud tenants. The API exposes access management and identity management endpoints, with additional endpoints specific to Advanced Identity Cloud tenant environments.<br /><br /> We are now publishing the API spec in OpenAPI 3.0. For the legacy Swagger 2.0 spec, please download [swagger.yaml](swagger.yaml), but note that it may not contain all new functionality.<br /><br /> For full PingOne Advanced Identity Cloud documentation, please visit [the docs website](https://docs.pingidentity.com/pingoneaic/latest/). ## Authenticating to the API The PingOne Advanced Identity Cloud REST API has two different authentication methods:   - [API key and secret](https://docs.pingidentity.com/pingoneaic/latest/developer-docs/authenticate-to-rest-api-with-api-key-and-secret.html): used for tenant read-only operations  - [Access token](https://docs.pingidentity.com/pingoneaic/latest/developer-docs/authenticate-to-rest-api-with-access-token.html): used for access management operations, identity management operations or tenant write operations  For a summary of how to use these authentication methods, refer to [Authenticate to Advanced Identity Cloud REST API](https://docs.pingidentity.com/pingoneaic/latest/developer-docs/authenticate-to-rest-api-overview.html).

API version:
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package identitycloud

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SecretsAPIService SecretsAPI service
type SecretsAPIService service

type ApiActionSecretRequest struct {
	ctx        context.Context
	ApiService *SecretsAPIService
	secretId   string
	action     *string
	body       *EsvSetDescriptionRequest
}

func (r ApiActionSecretRequest) Action(action string) ApiActionSecretRequest {
	r.action = &action
	return r
}

// The description of this secret
func (r ApiActionSecretRequest) Body(body EsvSetDescriptionRequest) ApiActionSecretRequest {
	r.body = &body
	return r
}

func (r ApiActionSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionSecretExecute(r)
}

/*
ActionSecret Set a secret description

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiActionSecretRequest
*/
func (a *SecretsAPIService) ActionSecret(ctx context.Context, secretId string) ApiActionSecretRequest {
	return ApiActionSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
func (a *SecretsAPIService) ActionSecretExecute(r ApiActionSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.ActionSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.action == nil {
		return nil, reportError("action is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "_action", r.action, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangeSecretVersionRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	action           *string
	secretId         string
	versionId        string
	body             *EsvSecretVersionStatusRequest
	acceptAPIVersion *string
}

// Can only be changestatus
func (r ApiChangeSecretVersionRequest) Action(action string) ApiChangeSecretVersionRequest {
	r.action = &action
	return r
}

// JSON body of the new status of the secret version
func (r ApiChangeSecretVersionRequest) Body(body EsvSecretVersionStatusRequest) ApiChangeSecretVersionRequest {
	r.body = &body
	return r
}

// resource&#x3D;2.0
func (r ApiChangeSecretVersionRequest) AcceptAPIVersion(acceptAPIVersion string) ApiChangeSecretVersionRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiChangeSecretVersionRequest) Execute() (*EsvSecretVersionResponse, *http.Response, error) {
	return r.ApiService.ChangeSecretVersionExecute(r)
}

/*
ChangeSecretVersion Update the status of a version of a secret

Update the status of a version of a secret to either ENABLED or DISABLED. The latest version of a secret cannot be updated to a status of DISABLED.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@param versionId ID of the secret version
	@return ApiChangeSecretVersionRequest
*/
func (a *SecretsAPIService) ChangeSecretVersion(ctx context.Context, secretId string, versionId string) ApiChangeSecretVersionRequest {
	return ApiChangeSecretVersionRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
		versionId:  versionId,
	}
}

// Execute executes the request
//
//	@return EsvSecretVersionResponse
func (a *SecretsAPIService) ChangeSecretVersionExecute(r ApiChangeSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretVersionResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalChangeSecretVersionExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalChangeSecretVersionExecute(r ApiChangeSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.ChangeSecretVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}/versions/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "_action", r.action, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSecretRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	body             *EsvSecretCreateRequest
	acceptAPIVersion *string
}

// JSON body of the new secret
func (r ApiCreateSecretRequest) Body(body EsvSecretCreateRequest) ApiCreateSecretRequest {
	r.body = &body
	return r
}

// resource&#x3D;2.0
func (r ApiCreateSecretRequest) AcceptAPIVersion(acceptAPIVersion string) ApiCreateSecretRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiCreateSecretRequest) Execute() (*EsvSecretResponse, *http.Response, error) {
	return r.ApiService.CreateSecretExecute(r)
}

/*
CreateSecret Create a secret

Create a secret and its first secret version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiCreateSecretRequest
*/
func (a *SecretsAPIService) CreateSecret(ctx context.Context, secretId string) ApiCreateSecretRequest {
	return ApiCreateSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
//
//	@return EsvSecretResponse
func (a *SecretsAPIService) CreateSecretExecute(r ApiCreateSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalCreateSecretExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalCreateSecretExecute(r ApiCreateSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.CreateSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSecretVersionRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	action           *string
	secretId         string
	body             *EsvSecretVersionCreateRequest
	acceptAPIVersion *string
}

// Can only be create
func (r ApiCreateSecretVersionRequest) Action(action string) ApiCreateSecretVersionRequest {
	r.action = &action
	return r
}

// JSON body of the new secret version
func (r ApiCreateSecretVersionRequest) Body(body EsvSecretVersionCreateRequest) ApiCreateSecretVersionRequest {
	r.body = &body
	return r
}

// resource&#x3D;2.0
func (r ApiCreateSecretVersionRequest) AcceptAPIVersion(acceptAPIVersion string) ApiCreateSecretVersionRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiCreateSecretVersionRequest) Execute() (*EsvSecretVersionResponse, *http.Response, error) {
	return r.ApiService.CreateSecretVersionExecute(r)
}

/*
CreateSecretVersion Create a new version of a secret

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiCreateSecretVersionRequest
*/
func (a *SecretsAPIService) CreateSecretVersion(ctx context.Context, secretId string) ApiCreateSecretVersionRequest {
	return ApiCreateSecretVersionRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
//
//	@return EsvSecretVersionResponse
func (a *SecretsAPIService) CreateSecretVersionExecute(r ApiCreateSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretVersionResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalCreateSecretVersionExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalCreateSecretVersionExecute(r ApiCreateSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.CreateSecretVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "_action", r.action, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSecretRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	acceptAPIVersion *string
}

// resource&#x3D;2.0
func (r ApiDeleteSecretRequest) AcceptAPIVersion(acceptAPIVersion string) ApiDeleteSecretRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiDeleteSecretRequest) Execute() (*EsvSecretResponse, *http.Response, error) {
	return r.ApiService.DeleteSecretExecute(r)
}

/*
DeleteSecret Delete a secret

Delete a secret and all its secret versions and secret version values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiDeleteSecretRequest
*/
func (a *SecretsAPIService) DeleteSecret(ctx context.Context, secretId string) ApiDeleteSecretRequest {
	return ApiDeleteSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
//
//	@return EsvSecretResponse
func (a *SecretsAPIService) DeleteSecretExecute(r ApiDeleteSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalDeleteSecretExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalDeleteSecretExecute(r ApiDeleteSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.DeleteSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSecretVersionRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	versionId        string
	acceptAPIVersion *string
}

// resource&#x3D;2.0
func (r ApiDeleteSecretVersionRequest) AcceptAPIVersion(acceptAPIVersion string) ApiDeleteSecretVersionRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiDeleteSecretVersionRequest) Execute() (*EsvSecretVersionResponse, *http.Response, error) {
	return r.ApiService.DeleteSecretVersionExecute(r)
}

/*
DeleteSecretVersion Delete a version of a secret

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@param versionId ID of the secret version
	@return ApiDeleteSecretVersionRequest
*/
func (a *SecretsAPIService) DeleteSecretVersion(ctx context.Context, secretId string, versionId string) ApiDeleteSecretVersionRequest {
	return ApiDeleteSecretVersionRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
		versionId:  versionId,
	}
}

// Execute executes the request
//
//	@return EsvSecretVersionResponse
func (a *SecretsAPIService) DeleteSecretVersionExecute(r ApiDeleteSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretVersionResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalDeleteSecretVersionExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalDeleteSecretVersionExecute(r ApiDeleteSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.DeleteSecretVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}/versions/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllSecretsRequest struct {
	ctx                context.Context
	ApiService         *SecretsAPIService
	acceptAPIVersion   *string
	pageSize           *int64
	pagedResultsCookie *string
	pagedResultsOffset *int64
	onlyPending        *bool
}

// resource&#x3D;2.0
func (r ApiGetAllSecretsRequest) AcceptAPIVersion(acceptAPIVersion string) ApiGetAllSecretsRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

// _Accept-API-Version: resource&#x3D;2.0_ only, maximum number of results returned by endpoint before paging
func (r ApiGetAllSecretsRequest) PageSize(pageSize int64) ApiGetAllSecretsRequest {
	r.pageSize = &pageSize
	return r
}

// _Accept-API-Version: resource&#x3D;2.0_ only, opaque data used for paging result data, can be used for paging instead of having to track pageSize and pagedResultsOffset
func (r ApiGetAllSecretsRequest) PagedResultsCookie(pagedResultsCookie string) ApiGetAllSecretsRequest {
	r.pagedResultsCookie = &pagedResultsCookie
	return r
}

// _Accept-API-Version: resource&#x3D;2.0_ only, offset of the first result to be returned by endpoint
func (r ApiGetAllSecretsRequest) PagedResultsOffset(pagedResultsOffset int64) ApiGetAllSecretsRequest {
	r.pagedResultsOffset = &pagedResultsOffset
	return r
}

// _Accept-API-Version: resource&#x3D;2.0_ only, returns ESVs with unapplied changes
func (r ApiGetAllSecretsRequest) OnlyPending(onlyPending bool) ApiGetAllSecretsRequest {
	r.onlyPending = &onlyPending
	return r
}

func (r ApiGetAllSecretsRequest) Execute() (*EsvSecretsListResponse, *http.Response, error) {
	return r.ApiService.GetAllSecretsExecute(r)
}

/*
GetAllSecrets Get all secrets

Get all secrets, but not their secret versions or secret version values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllSecretsRequest
*/
func (a *SecretsAPIService) GetAllSecrets(ctx context.Context) ApiGetAllSecretsRequest {
	return ApiGetAllSecretsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EsvSecretsListResponse
func (a *SecretsAPIService) GetAllSecretsExecute(r ApiGetAllSecretsRequest) (*EsvSecretsListResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretsListResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalGetAllSecretsExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalGetAllSecretsExecute(r ApiGetAllSecretsRequest) (*EsvSecretsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.GetAllSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_pageSize", r.pageSize, "")
	} else {
		var defaultValue int64 = 25
		r.pageSize = &defaultValue
	}
	if r.pagedResultsCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_pagedResultsCookie", r.pagedResultsCookie, "")
	} else {
		var defaultValue string = ""
		r.pagedResultsCookie = &defaultValue
	}
	if r.pagedResultsOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_pagedResultsOffset", r.pagedResultsOffset, "")
	} else {
		var defaultValue int64 = 0
		r.pagedResultsOffset = &defaultValue
	}
	if r.onlyPending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_onlyPending", r.onlyPending, "")
	} else {
		var defaultValue bool = false
		r.onlyPending = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecretRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	acceptAPIVersion *string
}

// resource&#x3D;2.0
func (r ApiGetSecretRequest) AcceptAPIVersion(acceptAPIVersion string) ApiGetSecretRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiGetSecretRequest) Execute() (*EsvSecretResponse, *http.Response, error) {
	return r.ApiService.GetSecretExecute(r)
}

/*
GetSecret Get a secret

Get a secret, but not its secret versions or secret version values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiGetSecretRequest
*/
func (a *SecretsAPIService) GetSecret(ctx context.Context, secretId string) ApiGetSecretRequest {
	return ApiGetSecretRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
//
//	@return EsvSecretResponse
func (a *SecretsAPIService) GetSecretExecute(r ApiGetSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalGetSecretExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalGetSecretExecute(r ApiGetSecretRequest) (*EsvSecretResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.GetSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecretVersionRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	versionId        string
	acceptAPIVersion *string
}

// resource&#x3D;2.0
func (r ApiGetSecretVersionRequest) AcceptAPIVersion(acceptAPIVersion string) ApiGetSecretVersionRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiGetSecretVersionRequest) Execute() (*EsvSecretVersionResponse, *http.Response, error) {
	return r.ApiService.GetSecretVersionExecute(r)
}

/*
GetSecretVersion Get a version of a secret

Get a version and version metadata of a secret. It is not possible to view the secret value.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@param versionId ID of the secret version
	@return ApiGetSecretVersionRequest
*/
func (a *SecretsAPIService) GetSecretVersion(ctx context.Context, secretId string, versionId string) ApiGetSecretVersionRequest {
	return ApiGetSecretVersionRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
		versionId:  versionId,
	}
}

// Execute executes the request
//
//	@return EsvSecretVersionResponse
func (a *SecretsAPIService) GetSecretVersionExecute(r ApiGetSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		err                 error
		response            *http.Response
		localVarReturnValue *EsvSecretVersionResponse
	)

	response, err = processResponse(
		func() (any, *http.Response, error) {
			return r.ApiService.internalGetSecretVersionExecute(r)
		},
		&localVarReturnValue,
	)
	return localVarReturnValue, response, err
}

func (a *SecretsAPIService) internalGetSecretVersionExecute(r ApiGetSecretVersionRequest) (*EsvSecretVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EsvSecretVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.GetSecretVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}/versions/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecretVersionsRequest struct {
	ctx              context.Context
	ApiService       *SecretsAPIService
	secretId         string
	acceptAPIVersion *string
}

// resource&#x3D;2.0
func (r ApiGetSecretVersionsRequest) AcceptAPIVersion(acceptAPIVersion string) ApiGetSecretVersionsRequest {
	r.acceptAPIVersion = &acceptAPIVersion
	return r
}

func (r ApiGetSecretVersionsRequest) Execute() ([]EsvSecretVersionResponse, *http.Response, error) {
	return r.ApiService.GetSecretVersionsExecute(r)
}

/*
GetSecretVersions Get all versions of a secret

Get all versions and version metadata of a secret. It is not possible to view the secret values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param secretId ID of the secret
	@return ApiGetSecretVersionsRequest
*/
func (a *SecretsAPIService) GetSecretVersions(ctx context.Context, secretId string) ApiGetSecretVersionsRequest {
	return ApiGetSecretVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		secretId:   secretId,
	}
}

// Execute executes the request
//
//	@return []EsvSecretVersionResponse
func (a *SecretsAPIService) GetSecretVersionsExecute(r ApiGetSecretVersionsRequest) ([]EsvSecretVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []EsvSecretVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsAPIService.GetSecretVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/secrets/{secretId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"secretId"+"}", url.PathEscape(parameterValueToString(r.secretId, "secretId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptAPIVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-API-Version", r.acceptAPIVersion, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v EsvError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v EsvError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
